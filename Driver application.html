<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Pasakay - Driver Application</title>  
  <link rel="icon" href="tricy.png" type="image/png">

  <!-- React CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>  

  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>  

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>  

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-auth.js";
    import { getDatabase, ref, onValue, get, set, update, push, runTransaction } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-database.js";
    import { getStorage, ref as storageRef, uploadBytes, getBytes, list, listAll, getMetadata } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-storage.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBS-g5bFBaJ6a35hWmjvoN-s8FuMEuxtew",
      authDomain: "pasakay-project-ph.firebaseapp.com",
      databaseURL: "https://pasakay-project-ph-default-rtdb.firebaseio.com",
      projectId: "pasakay-project-ph",
      storageBucket: "pasakay-project-ph.firebasestorage.app",
      messagingSenderId: "189297787561",
      appId: "1:189297787561:web:ddad5de3fdf638c6d8dfb8",
      measurementId: "G-2VWQ0C8EZE"
    };

    window.firebaseApiKey = firebaseConfig.apiKey;

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getDatabase(app);
    const storage = getStorage(app);

    // Admin session flags
    window.adminAllowed = false; // whether admin operations are allowed (only authenticated admin user with RoleID = 4)
    window.adminAnonymousAvailable = false; // whether anonymous sign-in is available (DEPRECATED - do not use)

    // NOTE: Anonymous sign-in is DISABLED in Firebase Console to enforce role-based access control.
    // Only users with RoleID = 4 in the database can access this admin dashboard.

    // Authentication Message and role enforcement
    // Strategy: Check custom claims first (preferred), fall back to DB role lookup
    onAuthStateChanged(auth, async (user) => {
      try {
        if (!user) {
          console.warn('‚ö†Ô∏è Not authenticated');
          window.currentUser = null;
          return;
        }

        // Keep anonymous admin session active
        if (user.isAnonymous) {
          console.log('‚úÖ Authenticated anonymously:', user.uid);
          window.currentUser = user;
          return;
        }

        // Non-anonymous sign-in detected (someone signed in with email/password)
        console.log('üîê Non-anonymous sign-in detected:', user.uid, user.email || 'no-email');

        // PREFERRED: Check for custom claim 'admin' in ID token
        let isAdminFromClaim = false;
        try {
          const idTokenResult = await user.getIdTokenResult();
          isAdminFromClaim = idTokenResult && idTokenResult.claims && idTokenResult.claims.admin === true;
          console.log('Custom claim check: admin=', isAdminFromClaim);
          if (isAdminFromClaim) {
            console.log('‚úÖ Admin user signed in via custom claim:', user.uid);
            window.currentUser = user;
            window.adminAllowed = true;
            return;
          }
        } catch (claimErr) {
          console.warn('getIdTokenResult failed; falling back to DB role check:', claimErr);
        }

        // FALLBACK: Check Realtime Database role lookup for users/<uid> with RoleID === 4 (admin)
        if (!window.db || !window.dbRef || !window.dbGet) {
          console.warn('DB helpers not available; denying non-admin access');
          try { await signOut(auth); } catch(e) { console.warn('signOut failed', e); }
          window.currentUser = null;
          window.adminAllowed = false;
          return;
        }

        const usersSnap = await window.dbGet(window.dbRef(window.db, 'users'));
        const usersVal = usersSnap && usersSnap.val() ? usersSnap.val() : {};
        console.log('üîç DEBUG: Searching for user with email:', user.email, 'and UID:', user.uid);
        console.log('üîç DEBUG: Available users in DB:', Object.keys(usersVal));
        
        let matched = null;
        for (const [uidKey, u] of Object.entries(usersVal)) {
          if (!u) continue;
          
          // Log each user's data for debugging
          console.log(`üîç DEBUG: Checking user ${uidKey}:`, {
            email: u.Email || u.email,
            authUID: u.AuthUID,
            roleID: u.RoleID,
            role: u.Role
          });
          
          if (u.AuthUID && String(u.AuthUID) === String(user.uid)) {
            console.log(`‚úÖ DEBUG: AuthUID match found for user ${uidKey}`);
            matched = { id: uidKey, rec: u };
            break;
          }
          const uEmail = (u.Email || u.email || '').toString().toLowerCase();
          if (user.email && uEmail && uEmail === (user.email||'').toString().toLowerCase()) {
            console.log(`‚úÖ DEBUG: Email match found for user ${uidKey}`);
            matched = { id: uidKey, rec: u };
            break;
          }
        }

        const isAdmin = (m) => {
          if (!m || !m.rec) {
            console.log('üîç DEBUG: isAdmin - no match or record');
            return false;
          }
          const r = m.rec.RoleID || m.rec.RoleId || m.rec.roleId || m.rec.role || m.rec.Role;
          if (!r) {
            console.log('üîç DEBUG: isAdmin - no RoleID found in record:', m.rec);
            return false;
          }
          
          // Check as number or string
          const roleNum = Number(r);
          const roleStr = String(r).toLowerCase();
          
          console.log(`üîç DEBUG: isAdmin check - RoleID value: "${r}", type: ${typeof r}, as number: ${roleNum}, as string: "${roleStr}"`);
          
          const isAdminCheck = roleNum === 4 || roleStr === '4' || roleStr === 'admin';
          console.log(`üîç DEBUG: isAdmin result: ${isAdminCheck}`);
          return isAdminCheck;
        };

        if (matched && isAdmin(matched)) {
          console.log('‚úÖ Admin user signed in via DB role lookup:', matched.id);
          console.log('‚úÖ Full user record:', matched.rec);
          window.currentUser = user;
          window.adminAllowed = true;
          return;
        }

        // User is not an admin ‚Äî deny access completely
        console.warn('‚õî Non-admin account attempted admin sign-in');
        console.warn('‚õî Matched user:', matched && matched.id);
        console.warn('‚õî Matched record:', matched && matched.rec);
        console.warn('‚õî Is admin check result:', matched ? isAdmin(matched) : 'no match');
        try {
          await signOut(auth);
          window.currentUser = null;
          window.adminAllowed = false;
          if (window.showAlert) window.showAlert('Access denied. Only users with RoleID = 4 can access this admin dashboard.', 'error');
          return;
        } catch(e) {
          console.warn('signOut failed', e);
          window.currentUser = null;
          window.adminAllowed = false;
          if (window.showAlert) window.showAlert('Access denied. Only users with RoleID = 4 can access this admin dashboard.', 'error');
          return;
        }
      } catch (err) {
        console.error('Error during auth role enforcement:', err);
        try { await signOut(auth); } catch(e) {}
        window.currentUser = null;
        window.adminAllowed = false;
      }
    });

    window.db = db;
    window.dbRef = ref;
    window.dbOnValue = onValue;
    window.dbGet = get;
    window.dbSet = set;
    window.dbUpdate = update;
    window.dbPush = push;
    window.dbRunTransaction = runTransaction;
    
    // Storage helpers
    window.storage = storage;
    window.storageRef = storageRef;
    window.uploadBytes = uploadBytes;
    window.getBytes = getBytes;
    window.storageList = list;
    window.storageListAll = listAll;
    window.getMetadata = getMetadata;
  </script>

  <script src="ui-modals.js"></script>

  <style>
    body {
      font-family: "Inter", sans-serif;
      background: #0a0e1a;
      margin: 0;
    }
    
    /* Customized Scrollbar */
    ::-webkit-scrollbar {
      width: 10px;
      height: 10px;
    }
    
    ::-webkit-scrollbar-track {
      background: #1a2333;
      border-radius: 10px;
    }
    
    ::-webkit-scrollbar-thumb {
      background: linear-gradient(180deg, #fbbf24 0%, #f59e0b 100%);
      border-radius: 10px;
    }
    
    ::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(180deg, #fcd34d 0%, #fbbf24 100%);
    }
    
    /* Firefox Scrollbar */
    * {
      scrollbar-color: #2e3c57 #1a2333;
      scrollbar-width: thin;
    }

    /* Applicants list custom scrollbar - dark blue theme */
    .applicants-scroll::-webkit-scrollbar {
      width: 8px;
    }

    .applicants-scroll::-webkit-scrollbar-track {
      background: #252d42;
      border-radius: 8px;
    }

    .applicants-scroll::-webkit-scrollbar-thumb {
      background: #2d3548;
      border-radius: 8px;
    }

    .applicants-scroll::-webkit-scrollbar-thumb:hover {
      background: #3d4558;
    }
  </style>
</head>  

<body>
  <div id="root"></div>  

  <script type="text/babel">
    // Helper: claim smallest available numeric id atomically (reuses gaps) - MOVED OUTSIDE COMPONENT
    // Returns a NUMBER (not a string) so it can be stored directly in the DB as an integer
    const claimSmallestNumericId = async (baseNode) => {
      if (!window.dbGet || !window.dbRef || !window.dbRunTransaction) throw new Error('DB helpers missing');
      const nodeRef = window.dbRef(window.db, baseNode);
      const snap = await window.dbGet(nodeRef);
      const keys = snap && snap.val() ? Object.keys(snap.val()) : [];
      const numericKeys = keys.map(k => parseInt(k, 10)).filter(n => Number.isInteger(n) && n > 0);
      const max = numericKeys.length ? Math.max(...numericKeys) : 0;

      for (let candidate = 1; candidate <= max; candidate++) {
        if (!numericKeys.includes(candidate)) {
          const allocRef = window.dbRef(window.db, `allocations/${baseNode}/${candidate}`);
          try {
            const tx = await window.dbRunTransaction(allocRef, (current) => {
              if (current) return; // already claimed
              return { reservedAt: Date.now() };
            });
            if (tx && tx.committed) return candidate; // Return NUMBER, not string
          } catch(e) {}
        }
      }

      const newId = max + 1;
      const allocRef2 = window.dbRef(window.db, `allocations/${baseNode}/${newId}`);
      await window.dbRunTransaction(allocRef2, (current) => {
        if (current) return; // someone else claimed
        return { reservedAt: Date.now() };
      });
      return newId; // Return NUMBER, not string
    };
    
    const TricycleManagement = () => {
      const createAuthUser = async (email, password) => {
        try {
          if (!email || !password) {
            console.warn('createAuthUser: email or password missing', { email: !!email, password: !!password });
            return null;
          }
          const key = window.firebaseApiKey;
          if (!key) {
            console.warn('Firebase API key not available; skipping Auth user creation');
            return null;
          }

          // Try to create the account; if the email already exists, fall back to sign-in
          const signUpUrl = `https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${encodeURIComponent(key)}`;
          const signInUrl = `https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=${encodeURIComponent(key)}`;

          const body = JSON.stringify({ email: String(email), password: String(password), returnSecureToken: true });
          console.log('createAuthUser: attempting signUp for email', email);
          let res = await fetch(signUpUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
          let json = await res.json();
          console.log('createAuthUser: signUp response status', res.status, 'body has error?', !!json?.error, 'localId?', !!json?.localId);
          console.log('createAuthUser: full response:', JSON.stringify(json, null, 2));
          if (!res.ok) {
            // Interpret common Identity Toolkit errors to guide admin action
            const errMsg = json && json.error && json.error.message ? json.error.message : null;
            if (errMsg === 'OPERATION_NOT_ALLOWED') {
              console.error('createAuthUser: Email/Password sign-up is disabled for this project (OPERATION_NOT_ALLOWED)');
              if (window.showAlert) window.showAlert('Email/Password sign-up is disabled in Firebase Console. Enable the Email/Password provider under Authentication ‚Üí Sign-in method.', 'error');
              return null;
            }
            if (errMsg === 'WEAK_PASSWORD : Password should be at least 6 characters') {
              if (window.showAlert) window.showAlert('Password is too weak. Use a stronger password (at least 6 characters).', 'error');
              return null;
            }

            // If the email already exists, attempt sign-in to obtain localId
            if (errMsg === 'EMAIL_EXISTS') {
              try {
                console.log('createAuthUser: email exists, attempting sign-in fallback');
                const res2 = await fetch(signInUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body });
                const json2 = await res2.json();
                if (res2.ok && json2 && json2.localId) {
                  console.log('createAuthUser: sign-in fallback SUCCESS, UID =', json2.localId);
                  return json2.localId;
                }
                console.warn('Sign-in fallback failed when email exists', json2);
                return null;
              } catch (e) {
                console.warn('Sign-in fallback error', e);
                return null;
              }
            }

            console.warn('Auth signUp failed', json);
            console.warn('Full error response:', JSON.stringify(json, null, 2));
            if (window.showAlert) window.showAlert('Failed to create Auth user: ' + (errMsg || 'unknown error'), 'error');
            return null;
          }

          // signUp succeeded; json.localId is the UID
          if (json && json.localId) {
            console.log('createAuthUser SUCCESS: new UID =', json.localId);
            return json.localId;
          }
          console.warn('createAuthUser: signUp ok but no localId in response', json);
          return null;
        } catch (e) {
          console.error('createAuthUser error', e);
          return null;
        }
      };

      // Ensure a Firebase Auth user exists for a DB user record.
      // Reads `users/<id>` and if `Email`+`Password` are present and `AuthUID` is missing,
      // creates the Auth user via Identity Toolkit and writes back `AuthUID`.
      const ensureAuthForUser = async (userId) => {
        try {
          if (!userId) {
            console.warn('ensureAuthForUser: userId is empty/falsy');
            return null;
          }
          console.log('ensureAuthForUser: checking user', userId);
          const userRef = window.dbRef(window.db, `users/${userId}`);
          const snap = await window.dbGet(userRef);
          const userObj = snap && snap.exists() ? snap.val() : {};
          console.log('ensureAuthForUser: user record read from DB:', userObj);
          const email = userObj && (userObj.Email || userObj.email);
          const password = userObj && (userObj.Password || userObj.password);
          const existing = userObj && (userObj.AuthUID || userObj.authUid || userObj.authUID);
          console.log('ensureAuthForUser: email present?', !!email, 'password present?', !!password, 'AuthUID existing?', !!existing);
          if (!email || !password) {
            console.warn('ensureAuthForUser: email or password missing, skipping Auth creation');
            return null;
          }
          if (existing) {
            console.log('ensureAuthForUser: AuthUID already exists:', existing);
            return existing;
          }
          console.log('ensureAuthForUser: calling createAuthUser');
          const uid = await createAuthUser(email, password);
          if (uid) {
            console.log('ensureAuthForUser: Auth user created with UID:', uid, '- writing to DB');
            try {
              await window.dbUpdate(userRef, { AuthUID: uid });
              console.log('ensureAuthForUser: AuthUID written to DB successfully');
            } catch(e) {
              console.warn('ensureAuthForUser: Failed to write AuthUID to DB', e);
            }
            return uid;
          } else {
            console.warn('ensureAuthForUser: createAuthUser returned null/falsy');
          }
          return null;
        } catch (e) {
          console.warn('ensureAuthForUser error', e);
          return null;
        }
      };
      const [showModal, setShowModal] = React.useState(false);
      // Force re-render when global auth flags change (window.currentUser / window.adminAllowed)
      const [, setAuthTick] = React.useState(0);
      const _lastAuth = React.useRef({ u: undefined, a: undefined });
      React.useEffect(() => {
        const id = setInterval(() => {
          try {
            const u = window.currentUser;
            const a = window.adminAllowed;
            if (u !== _lastAuth.current.u || a !== _lastAuth.current.a) {
              _lastAuth.current = { u, a };
              setAuthTick(t => t + 1);
            }
          } catch (e) {}
        }, 250);
        return () => clearInterval(id);
      }, []);
      const [showAddDriverModal, setShowAddDriverModal] = React.useState(false);
      const [selected, setSelected] = React.useState(null);
      const [selectedIndex, setSelectedIndex] = React.useState(null);

      // Applicants data from Realtime Database
      const [applicants, setApplicants] = React.useState([]);
      const [statusFilter, setStatusFilter] = React.useState('ALL');
      const [searchQuery, setSearchQuery] = React.useState('');
      const [isProcessing, setIsProcessing] = React.useState(false);

      // Raw drivers and users from DB (we now derive applicants from users where RoleID === 2)
      const [rawDrivers, setRawDrivers] = React.useState({});
      const [rawUsers, setRawUsers] = React.useState({});
      const [selectedPasswordVisible, setSelectedPasswordVisible] = React.useState(false);

      // Helper function for status colors (must be before useEffect that uses it)
      const getStatusColor = (status) => {
          const statusStr = (status || '').toString().toUpperCase();
          // If ApplicationStatus contains 'ADDED', display as ADDED (green)
          if (statusStr.includes('ADDED')) return "bg-blue-600";
          // Extract base status (first word before space or hyphen)
          const baseStatus = statusStr.split(/[\s\-]/)[0];
          switch(baseStatus) {
            case "TO": return "bg-yellow-500"; // "TO REVIEW"
            case "APPROVED": return "bg-green-500";
            case "EXPIRED": return "bg-red-500";
            case "REJECTED": return "bg-red-500";
            default: return "bg-gray-500";
          }
      };

      // Helper to format status for display
      const formatStatusForDisplay = (appStatus) => {
        const statusStr = (appStatus || '').toString().toUpperCase();
        // If contains 'ADDED', display as just 'ADDED'
        if (statusStr.includes('ADDED')) return 'ADDED';
        // Otherwise show the full status
        const words = statusStr.split(/[\s\-]/).filter(Boolean);
        if (words[0] === 'TO') return 'TO REVIEW';
        return words[0] || 'TO REVIEW';
      };

      // Listen to drivers and users nodes so we can display canonical data for applicants when available
      React.useEffect(() => {
        if (!window.db || !window.dbRef || !window.dbOnValue) return;
        const driversRef = window.dbRef(window.db, 'drivers');
        const usersRef = window.dbRef(window.db, 'users');
        const unsubD = window.dbOnValue(driversRef, snap => setRawDrivers(snap.val() || {}));
        const unsubU = window.dbOnValue(usersRef, snap => setRawUsers(snap.val() || {}));
        return () => { try { unsubD(); } catch(e) {} try { unsubU(); } catch(e) {} };
      }, []);

      // Recompute merged applicants list whenever users or drivers change;
      // applicants are derived from users where RoleID === 2 (drivers) and merged with drivers/ record when available
      React.useEffect(() => {
        try { console.debug('Recomputing applicants from rawUsers/rawDrivers', Object.keys(rawUsers||{}).length, Object.keys(rawDrivers||{}).length); } catch(e) {}
        const usersVal = rawUsers || {};
        const items = [];

        for (const [userId, userRec] of Object.entries(usersVal)) {
          if (!userRec) continue;
          // Only consider users with RoleID === 2 (driver role per new flow)
          if (String(userRec.RoleID) !== '2') continue;
          // Skip soft-deleted users
          if (userRec.DeletedAt) continue;

          // find driver record for this user (if any)
          let drvEntry = null;
          for (const [drvId, drv] of Object.entries(rawDrivers || {})) {
            if (!drv) continue;
            if (String(drv.UserID) === String(userId)) {
              drvEntry = { id: drvId, rec: drv };
              break;
            }
          }

          const name = [userRec.Firstname, userRec.Middlename, userRec.Lastname].filter(Boolean).join(' ') || userRec.name || 'Applicant';
          const contact = userRec.MobileNumber || userRec.contact || '';
          const license = drvEntry ? (drvEntry.rec.LicenseNumber || drvEntry.rec.license || '') : '';
          const plate = drvEntry ? (drvEntry.rec.TricyclePlateNumber || drvEntry.rec.TricycleNumber || '') : '';
          const franchiseExpiry = drvEntry ? (drvEntry.rec.FranchiseExpiry || '') : '';
          const appStatus = drvEntry ? (drvEntry.rec.ApplicationStatus || drvEntry.rec.Status || 'TO REVIEW') : 'TO REVIEW';

          const statusRaw = (appStatus || 'TO REVIEW').toString();
          const statusWords = statusRaw.toUpperCase().split(/[\s\-]/).filter(Boolean);
          let status = formatStatusForDisplay(appStatus);

          const initials = (name || 'Applicant').split(' ').map(n => n[0]||'').join('').slice(0,2).toUpperCase();

          items.push({
            id: `user-${userId}`,
            userId: userId,
            drvId: drvEntry ? drvEntry.id : null,
            name,
            email: userRec.Email || userRec.email || '',
            contact,
            license,
            plate,
            status,
            registeredDate: formatIsoForDisplay(userRec.CreatedAt || ''),
            franchiseExpiry,
            initials,
            color: getStatusColor(status),
            files: drvEntry && drvEntry.rec.files ? drvEntry.rec.files : {}
          });
        }

        // Also include any drivers that reference users not present (defensive)
        for (const [drvId, drv] of Object.entries(rawDrivers || {})) {
          if (!drv) continue;
          if (drv.UserID && rawUsers && rawUsers[String(drv.UserID)]) continue; // already included
          const name = drv.Name || drv.name || 'Applicant';
          const contact = drv.MobileNumber || drv.contact || '';
          const license = drv.LicenseNumber || drv.license || '';
          const plate = drv.TricyclePlateNumber || drv.TricycleNumber || '';
          const statusRaw = (drv.ApplicationStatus || drv.Status || 'TO REVIEW').toString();
          const statusWords = statusRaw.toUpperCase().split(/[\s\-]/).filter(Boolean);
          const status = formatStatusForDisplay(drv.ApplicationStatus || drv.Status || 'TO REVIEW');
          const initials = (name || 'Applicant').split(' ').map(n => n[0]||'').join('').slice(0,2).toUpperCase();
          items.push({
            id: `drv-${drvId}`,
            drvId,
            userId: drv.UserID || null,
            email: drv.Email || drv.email || '',
            name,
            contact,
            license,
            plate,
            status,
            registeredDate: formatIsoForDisplay(drv.CreatedAt || ''),
            franchiseExpiry: drv.FranchiseExpiry || '',
            initials,
            color: getStatusColor(status),
            files: drv.files || {}
          });
        }

        setApplicants(items);
      }, [rawDrivers, rawUsers]);

      // Date formatting helpers: display without 'T' and without milliseconds/Z
      const formatIsoForDisplay = (iso) => {
        if (!iso) return '';
        try {
          const s = iso.toString();
          // Remove 'T', '.000Z', 'Z', and milliseconds
          let result = s.replace('T', ' ');
          result = result.replace(/\.\d{3}Z?$/, '');
          result = result.replace(/Z$/, '');
          return result;
        } catch (e) { return iso; }
      };

      // Convert displayed 'YYYY-MM-DD HH:MM:SS' back to ISO-like string
      const displayToIso = (s) => {
        if (!s) return '';
        const m = s.toString().match(/^(\d{4}-\d{2}-\d{2})[ T](\d{2}:\d{2}:\d{2})$/);
        if (m) {
          return `${m[1]}T${m[2]}.000Z`;
        }
        return s;
      };

      // Validation helpers (shared with Driver Management patterns)
      const formatLicense = (value) => {
        if (!value) return '';
        const up = value.toString().toUpperCase();
        const raw = up.replace(/[^A-Z0-9]/g, '');
        const p1 = raw.slice(0, 3);
        const p2 = raw.slice(3, 5);
        const p3 = raw.slice(5, 11);
        let formatted = p1;
        if (p2) formatted += '-' + p2;
        if (p3) formatted += '-' + p3;
        return formatted;
      };

      const isValidLicense = (value) => {
        return /^[A-Z]\d{2}-\d{2}-\d{6}$/.test((value||'').toString());
      };

      const normalizeLicenseForCompare = (value) => {
        return (value||'').toString().toUpperCase().replace(/[^A-Z0-9]/g, '');
      };

      // Helper: strip +63 prefix for display
      const stripPhonePrefix = (phone) => {
        if (!phone) return '';
        const str = phone.toString();
        if (str.startsWith('+63')) return str.slice(3);
        return str;
      };

      // Helper: Detect file type from URL or filename
      const getFileType = (url) => {
        if (!url) return 'unknown';
        const urlStr = String(url).toLowerCase();
        if (urlStr.includes('.pdf') || urlStr.includes('pdf')) return 'pdf';
        if (urlStr.includes('.png') || urlStr.includes('.jpg') || urlStr.includes('.jpeg') || urlStr.includes('.gif') || urlStr.includes('.webp')) return 'image';
        if (urlStr.includes('.doc') || urlStr.includes('.docx')) return 'document';
        return 'file';
      };

      // Helper: Get file name from URL (extract filename from path)
      const getFileNameFromUrl = (url) => {
        if (!url) return 'document';
        try {
          const urlObj = new URL(url);
          const pathname = urlObj.pathname || '';
          // Last path segment may be an encoded path like "drivers%2F2%2Ffile.pdf".
          let filename = pathname.substring(pathname.lastIndexOf('/') + 1) || '';
          // Decode URL-encoded characters (so drivers%2F2%2Ffile.pdf -> drivers/2/file.pdf)
          filename = decodeURIComponent(filename);
          // If there are slashes after decoding, take the basename
          if (filename.includes('/')) {
            filename = filename.substring(filename.lastIndexOf('/') + 1);
          }
          return filename || 'document';
        } catch (e) {
          return 'document';
        }
      };

      // Helper: Map driver document URL fields to document types
      const getDocumentsFromDriver = (drv) => {
        if (!drv) return {};
        
        const docs = {};
        
        // Map DriversLicenseUrl to license
        if (drv.DriversLicenseUrl) {
          docs.license = {
            documentType: 'license',
            downloadUrl: drv.DriversLicenseUrl,
            fileName: getFileNameFromUrl(drv.DriversLicenseUrl) || 'drivers-license',
            fileType: getFileType(drv.DriversLicenseUrl),
            uploadedAt: drv.DriversLicenseUploadedAt || null
          };
        }
        
        // Map NbiClearanceUrl to nbi
        if (drv.NbiClearanceUrl) {
          docs.nbi = {
            documentType: 'nbi',
            downloadUrl: drv.NbiClearanceUrl,
            fileName: getFileNameFromUrl(drv.NbiClearanceUrl) || 'nbi-clearance',
            fileType: getFileType(drv.NbiClearanceUrl),
            uploadedAt: drv.NbiClearanceUploadedAt || null
          };
        }
        
        // Map QcIdUrl to qc
        if (drv.QcIdUrl) {
          docs.qc = {
            documentType: 'qc',
            downloadUrl: drv.QcIdUrl,
            fileName: getFileNameFromUrl(drv.QcIdUrl) || 'qc-id',
            fileType: getFileType(drv.QcIdUrl),
            uploadedAt: drv.QcIdUploadedAt || null
          };
        }
        
        // Map DrugTestUrl to drug
        if (drv.DrugTestUrl) {
          docs.drug = {
            documentType: 'drug',
            downloadUrl: drv.DrugTestUrl,
            fileName: getFileNameFromUrl(drv.DrugTestUrl) || 'drug-test',
            fileType: getFileType(drv.DrugTestUrl),
            uploadedAt: drv.DrugTestUploadedAt || null
          };
        }
        
        return docs;
      };

      const openModal = (index) => {
        // Prefill the modal with applicant values. If this row is backed by a drivers/<id> record,
        // prefer canonical driver/user values so edits can be persisted back to drivers/users.
        const app = applicants[index] || {};
        const base = { 
          ...app,
          // Ensure all fields are initialized (prevents undefined values)
          plate: app.plate || '',
          tricycleNumber: app.tricycleNumber || '',
          license: app.license || '',
          name: app.name || '',
          contact: app.contact || '',
          registeredDate: app.registeredDate || '',
          franchiseExpiry: app.franchiseExpiry || ''
        };
        
        // Ensure UserID is always captured. Our applicants come from users/ (id like 'user-<id>')
        if (!base.UserID) {
          if (app.userId) base.UserID = app.userId || '';
          else if (app.id && typeof app.id === 'string' && app.id.startsWith('user-')) base.UserID = app.id.replace(/^user-/, '');
        }

        // If this row maps to a driver record (drvId), prefill license/tricycle from that driver
        try {
          if (app.drvId) {
            const drv = rawDrivers && rawDrivers[String(app.drvId)];
            if (drv) {
              base.UserID = drv.UserID || base.UserID || '';
              base.license = drv.LicenseNumber || drv.license || base.license || '';
              base.plate = drv.TricyclePlateNumber || base.plate || '';
              base.tricycleNumber = drv.TricycleNumber || base.tricycleNumber || '';
              base.franchiseExpiry = drv.FranchiseExpiry || base.franchiseExpiry || '';
              const userRec = rawUsers && rawUsers[drv.UserID];
              if (userRec) {
                base.contact = stripPhonePrefix(userRec.MobileNumber || base.contact || '');
                base.name = [userRec.Firstname, userRec.Middlename, userRec.Lastname].filter(Boolean).join(' ') || base.name;
                base.email = userRec.Email || userRec.email || '';
              }
              base.registeredDate = formatIsoForDisplay(drv.CreatedAt || drv.registeredDate || base.registeredDate || '');
            }
          }
        } catch (e) {}
        
        try {
          if (app.id && typeof app.id === 'string' && app.id.startsWith('drv-')) {
            const drvId = app.id.replace(/^drv-/, '');
            const drv = rawDrivers && rawDrivers[String(drvId)];
              if (drv) {
              base.UserID = drv.UserID || base.UserID || '';
              base.license = drv.LicenseNumber || drv.license || base.license || '';
                // Prefer explicit plate field if present, but also capture dedicated tricycle number when available
                base.plate = drv.TricyclePlateNumber || base.plate || '';
                base.tricycleNumber = drv.TricycleNumber || base.tricycleNumber || '';
              base.franchiseExpiry = drv.FranchiseExpiry || drv.franchiseExpiry || base.franchiseExpiry || '';
              // prefer user mobile/name
              const userRec = rawUsers && rawUsers[drv.UserID];
              if (userRec) {
                base.contact = stripPhonePrefix(userRec.MobileNumber || base.contact || '');
                base.name = [userRec.Firstname, userRec.Middlename, userRec.Lastname].filter(Boolean).join(' ') || base.name;
                base.email = userRec.Email || userRec.email || '';
              }
              // format registeredDate for display
              base.registeredDate = formatIsoForDisplay(drv.CreatedAt || drv.registeredDate || base.registeredDate || '');
            }
          }
        } catch (e) {}

        // ApplicationStatus is stored in drivers/ when present; otherwise default to TO REVIEW
        try {
          if (base.drvId) {
            const drv = rawDrivers && rawDrivers[String(base.drvId)];
            base.ApplicationStatus = (drv && (drv.ApplicationStatus || drv.Status) ? (drv.ApplicationStatus || drv.Status) : 'TO REVIEW').toString().toUpperCase();
          } else {
            base.ApplicationStatus = (base.status || 'TO REVIEW').toString().toUpperCase();
          }
        } catch (e) {
          base.ApplicationStatus = 'TO REVIEW';
        }
        // Display status mirrors ApplicationStatus here (do not convert APPROVED -> ADDED in this view)
        try {
          base.displayStatus = base.ApplicationStatus || 'TO REVIEW';
        } catch (e) { base.displayStatus = base.ApplicationStatus || 'TO REVIEW'; }

        // Load documents from Realtime Database if driver has documents node
        // Also load from driver URL fields (DriversLicenseUrl, NbiclearanceUrl, QcIdUrl, DrugTestUrl)
        try {
          if (base.drvId && rawDrivers && rawDrivers[String(base.drvId)]) {
            const drv = rawDrivers[String(base.drvId)];
            
            // First, get documents from the documents node (if it exists)
            let docs = {};
            if (drv.documents) {
              docs = { ...drv.documents };
            }
            
            // Then, merge in documents from driver URL fields (these will override or complement)
            const docsFromUrls = getDocumentsFromDriver(drv);
            docs = { ...docs, ...docsFromUrls };
            
            base.documents = docs;
          } else {
            base.documents = {};
          }
        } catch (e) {
          base.documents = {};
        }

        // Strip +63 prefix from contact for display (will be re-added on save)
        if (base.contact) {
          base.contact = stripPhonePrefix(base.contact);
        }
        // include password for editing when user record exists
        try {
          if (base.UserID && rawUsers && rawUsers[base.UserID]) {
            base.password = rawUsers[base.UserID].Password || rawUsers[base.UserID].password || '';
          }
        } catch (e) {}
        setSelectedIndex(index);
        setSelected(base);
        setShowModal(true);
      };

      const closeModal = () => {
        setShowModal(false);
        setSelected(null);
        setSelectedIndex(null);
      };

      const handleInputChange = (e) => {
        const { name, value } = e.target;
        setSelected((prev) => ({
          ...prev,
          [name]: value,
        }));
      };

      const saveChanges = async () => {
        if (selectedIndex !== null && selected && selected.id) {
          if (!window.adminAllowed) {
            window.showAlert('Admin session unavailable. Sign in with an admin account or enable anonymous admin sign-in.', 'error');
            return;
          }
          // prefer ApplicationStatus field; fallback to legacy status
          const appStatus = (selected.ApplicationStatus || selected.Application_Status || selected.status || 'TO REVIEW').toString().toUpperCase();
          try { console.debug('saveChanges:', {
            selectedApplicationStatus: selected.ApplicationStatus,
            selectedStatus: selected.status,
            appStatus: appStatus,
            allSelected: JSON.stringify(selected)
          }); } catch(e) {}
          // Validate contact length (should be 11 digits - +63 prefix is added automatically)
          const contactDigits = selected.contact.toString().replace(/\D/g, '');
          if (!contactDigits || contactDigits.length !== 11) {
            window.showAlert('Phone number must be exactly 11 digits (format: +63 followed by 09XX XXXX XXX)', 'error');
            return;
          }

          // Format license if present and validate
          let formattedLicense = '';
          if (selected.license) {
            formattedLicense = formatLicense(selected.license);
            if (!isValidLicense(formattedLicense)) {
              window.showAlert('License number must match format like A01-23-456789', 'error');
              return;
            }
            // Check uniqueness across drivers only if license was modified
            try {
              const normNew = normalizeLicenseForCompare(formattedLicense);
              // get original license for this row (if available) and normalize
              const original = (applicants && applicants[selectedIndex] && (applicants[selectedIndex].license || applicants[selectedIndex].LicenseNumber || '')) || '';
              const normOriginal = normalizeLicenseForCompare(original);
              // Only validate uniqueness when the normalized license actually changed
              if (normNew && normNew !== normOriginal) {
                for (const [k, d] of Object.entries(rawDrivers || {})) {
                  if (!d) continue;
                  const normExisting = normalizeLicenseForCompare(d.LicenseNumber || d.license || '');
                  // Exclude current driver from uniqueness check
                  const isSameDriver = (selected.id && selected.id.startsWith('drv-') && selected.id.replace(/^drv-/, '') === k);
                  if (normExisting && normExisting === normNew && !isSameDriver) {
                    window.showAlert('License number already exists. Please use a unique license number.', 'error');
                    return;
                  }
                }
              }
            } catch (e) {}
          }

          const payload = {
            name: selected.name,
            email: selected.email || '',
            contact: contactDigits.length === 11 ? '+63' + contactDigits : selected.contact,
            license: formattedLicense || selected.license || '',
            plate: selected.plate || '',
            tricycleNumber: selected.tricycleNumber || '',
            // convert displayed date back to ISO-ish string before saving
            registeredDate: displayToIso(selected.registeredDate) || selected.registeredDate || '',
            franchiseExpiry: selected.franchiseExpiry || '',
            ApplicationStatus: appStatus,
            status: appStatus // keep legacy field in sync for UI compatibility
          };

          // If this row was synthesized from a drivers/ record (id like 'drv-<id>'), persist the status back to drivers/<id>
          if (typeof selected.id === 'string' && selected.id.startsWith('drv-')) {
            const drvId = selected.id.replace(/^drv-/, '');
            const drvRef = window.dbRef(window.db, `drivers/${drvId}`);
            try {
              // Determine final application status. If admin set to APPROVED but the
              // linked user is already active, treat this as ADDED and clear IsApplying.
              let finalAppStatus = appStatus;
              const drvRec = rawDrivers && rawDrivers[String(drvId)];
              const linkedUserId = drvRec && drvRec.UserID;
              try {
                const scheck = (appStatus || '').toString().toUpperCase();
                if (scheck.includes('APPROVED') && linkedUserId) {
                  try {
                    const userRefCheck = window.dbRef(window.db, `users/${linkedUserId}`);
                    const userSnapCheck = await window.dbGet(userRefCheck);
                    const userObjCheck = userSnapCheck.exists() ? userSnapCheck.val() : {};
                    if (userObjCheck && userObjCheck.IsActive) {
                      finalAppStatus = 'ADDED';
                    }
                  } catch (e) {
                    console.warn('Failed to check linked user IsActive for driver update', e);
                  }
                }
              } catch(e) {}

              // Update driver ApplicationStatus and any edited fields (license, tricycle, contact, franchiseExpiry)
              const driverUpdatePayload = { ApplicationStatus: finalAppStatus };
              // include formatted license if provided
              if (payload.license) driverUpdatePayload.LicenseNumber = payload.license;
              // Persist plate and tricycle number as SEPARATE fields (always write explicit fields)
              driverUpdatePayload.TricyclePlateNumber = payload.plate || '';
              driverUpdatePayload.TricycleNumber = payload.tricycleNumber || '';
              if (payload.franchiseExpiry) driverUpdatePayload.FranchiseExpiry = payload.franchiseExpiry;
              // Update status label only; driver activation/online state are managed in Driver Management
              // Set Status active only for approved/added application states; otherwise mark inactive.
              try {
                const s = (finalAppStatus || '').toString().toUpperCase();
                if (s.includes('APPROVED') || s.includes('ADDED')) {
                  driverUpdatePayload.Status = 'Active';
                } else {
                  driverUpdatePayload.Status = 'Inactive';
                }
              } catch (e) {
                driverUpdatePayload.Status = 'Inactive';
              }

              // Ensure IsApplying flag follows final status: when ADDED -> false, otherwise preserve existing or true
              try {
                if (finalAppStatus === 'ADDED') {
                  driverUpdatePayload.IsApplying = false;
                } else if (typeof drvRec !== 'undefined' && typeof drvRec.IsApplying !== 'undefined') {
                  driverUpdatePayload.IsApplying = drvRec.IsApplying;
                } else {
                  driverUpdatePayload.IsApplying = true;
                }
              } catch (e) { driverUpdatePayload.IsApplying = true; }

              try { console.debug('Updating driver', drvId, 'with payload:', driverUpdatePayload); } catch(e) {}
              await window.dbUpdate(drvRef, driverUpdatePayload);
              try { console.debug('Driver update completed for', drvId); } catch(e) {}

              // applications/ node is no longer the canonical source in the new flow.
              // Drivers/ is canonical for application status; we avoid touching applications/ here.

              // Send notification to linked user (if available) and update user contact/name if edited
              try {
                const drvRec = rawDrivers && rawDrivers[String(drvId)];
                const userId = drvRec && drvRec.UserID;
                if (userId) {
                  // update user contact/name if provided
                  try {
                    const userRef = window.dbRef(window.db, `users/${userId}`);
                    const userSnap = await window.dbGet(userRef);
                    const userObj = userSnap.exists() ? userSnap.val() : {};
                    // split name into parts
                    const nameParts = (payload.name || '').trim().split(/\s+/).filter(Boolean);
                    if (nameParts.length) {
                      userObj.Firstname = nameParts[0] || userObj.Firstname || '';
                      userObj.Lastname = nameParts.length > 1 ? nameParts[nameParts.length-1] : userObj.Lastname || '';
                      userObj.Middlename = nameParts.length > 2 ? nameParts.slice(1, -1).join(' ') : userObj.Middlename || '';
                    }
                    if (payload.contact) userObj.MobileNumber = payload.contact;
                    if (payload.email) userObj.Email = payload.email;
                    // update password if admin edited it in modal
                    if (selected && (typeof selected.password !== 'undefined')) {
                      userObj.Password = selected.password || '';
                    }
                    await window.dbSet(userRef, userObj);
                    try { await ensureAuthForUser(userId); } catch(e) { console.warn('ensureAuthForUser failed after driver edit dbSet', e); }
                  } catch (e) {
                    console.warn('Failed to update user record for driver edit', e);
                  }

                  const notifRef = window.dbRef(window.db, `users/${userId}/notifications/${Date.now()}`);
                  await window.dbSet(notifRef, {
                    type: 'APPLICATION_STATUS_UPDATE',
                    message: `Your application status is now ${appStatus}`,
                    createdAt: Date.now(),
                    seen: false
                  });
                }
              } catch (e) {
                console.warn('Failed to send notification to user for driver status change', e);
              }

              // Update local rawDrivers and applicants view
              try {
                const updatedApplicants = [...applicants];
                // Compute display status: if APPROVED and a driver exists, show ADDED (display-only)
                let displayStatusAfter = appStatus;
                try {
                  // Keep display status consistent with ApplicationStatus; mapping to 'ADDED' only happens in Driver Management
                  // (do not convert 'APPROVED' to 'ADDED' here)
                } catch (e) {}

                updatedApplicants[selectedIndex] = { ...updatedApplicants[selectedIndex], ...payload, status: displayStatusAfter, color: getStatusColor(displayStatusAfter) };
                setApplicants(updatedApplicants);

                // Update rawDrivers immutably so React picks up change
                setRawDrivers(prev => {
                  const copy = { ...(prev || {}) };
                  copy[drvId] = { ...(copy[drvId] || {}), ...driverUpdatePayload };
                  return copy;
                });

                // Force a fresh read to ensure listeners and other tabs reflect canonical data
                try {
                  const driversSnap = await window.dbGet(window.dbRef(window.db, 'drivers'));
                  const drvVal = driversSnap.val() || {};
                  setRawDrivers(drvVal);
                  try { console.debug('Refreshed drivers after update', Object.keys(drvVal).length); } catch(e) {}
                } catch(e) { console.warn('Failed to refresh drivers after update', e); }
              } catch (e) { console.warn('Error updating local state after driver update', e); }

              window.showAlert("Application status saved for " + selected.name, 'success');
              closeModal();
            } catch (err) {
              console.error('Error updating driver ApplicationStatus:', err);
              window.showAlert('Error saving changes to driver: ' + (err.message || err), 'error');
            }
            return;
          }

          // Default: write to applications/<id>
          // Store essential fields in applications/ (reference users/ for name, email, phone)
          const appRef = window.dbRef(window.db, `applications/${selected.id}`);
          const userIdVal = selected.UserID || (applicants && applicants[selectedIndex] && applicants[selectedIndex].UserID) || '';
          const appPayload = {
            UserID: userIdVal ? parseInt(userIdVal, 10) : null,
            ApplicationStatus: appStatus,
            LicenseNumber: formattedLicense || selected.license || '', // Store license in applications
            TricyclePlateNumber: selected.plate || '', // explicit plate
            TricycleNumber: selected.tricycleNumber || '' // internal number (no fallback to plate)
          };
          // If admin edited password on the modal and this application references a user, persist password to users/<id>
          try {
            if (userIdVal && (typeof selected.password !== 'undefined')) {
              await window.dbUpdate(window.dbRef(window.db, `users/${userIdVal}`), { Password: selected.password || '' });
              try { await ensureAuthForUser(userIdVal); } catch(e) { console.warn('ensureAuthForUser failed after password update (1)', e); }
            }
          } catch (e) {
            console.warn('Failed to update user password for application edit', e);
          }
          // Persist applicant changes via users/ and drivers/ (applications/ is deprecated)
          try {
            const userIdVal = selected.userId || (selected.id && selected.id.startsWith('user-') ? selected.id.replace(/^user-/, '') : selected.UserID || '');
            // persist password to users/<id> if admin edited it
            try {
              if (userIdVal && (typeof selected.password !== 'undefined')) {
                await window.dbUpdate(window.dbRef(window.db, `users/${userIdVal}`), { Password: selected.password || '' });
                try { await ensureAuthForUser(userIdVal); } catch(e) { console.warn('ensureAuthForUser failed after password update (2)', e); }
              }
            } catch (e) { console.warn('Failed to update user password for applicant edit', e); }

            // If this applicant already has a driver record, update it
            if (selected.drvId) {
              const drvKey = selected.drvId;
              // Determine final status for this driver update (see drv- path logic above)
              let finalApp = appStatus;
              try {
                const s2 = (appStatus || '').toString().toUpperCase();
                if (s2.includes('APPROVED') && userIdVal) {
                  try {
                    const userRefCheck2 = window.dbRef(window.db, `users/${userIdVal}`);
                    const userSnapCheck2 = await window.dbGet(userRefCheck2);
                    const userObjCheck2 = userSnapCheck2.exists() ? userSnapCheck2.val() : {};
                    if (userObjCheck2 && userObjCheck2.IsActive) {
                      finalApp = 'ADDED';
                    }
                  } catch (e) { console.warn('Failed to check user IsActive for applicant->driver update', e); }
                }
              } catch (e) {}

              const driverUpdate = { ApplicationStatus: finalApp };
              // Do not toggle driver/user activation or online flags here; only update status label
              try {
                const s2 = (finalApp || '').toString().toUpperCase();
                driverUpdate.Status = (s2.includes('APPROVED') || s2.includes('ADDED')) ? 'Active' : 'Inactive';
              } catch (e) {
                driverUpdate.Status = 'Inactive';
              }
              driverUpdate.TricyclePlateNumber = payload.plate || '';
              driverUpdate.TricycleNumber = payload.tricycleNumber || '';
              if (payload.license) driverUpdate.LicenseNumber = payload.license;
              if (payload.franchiseExpiry) driverUpdate.FranchiseExpiry = payload.franchiseExpiry;
              // IsApplying flips false if finalApp is ADDED
              try { driverUpdate.IsApplying = (finalApp === 'ADDED' ? false : true); } catch(e) { driverUpdate.IsApplying = true; }
              await window.dbUpdate(window.dbRef(window.db, `drivers/${drvKey}`), driverUpdate);

              // update user contact/name if present
              try {
                if (userIdVal) {
                  const userRef = window.dbRef(window.db, `users/${userIdVal}`);
                  const nameParts = (payload.name || '').trim().split(/\s+/).filter(Boolean);
                  const toUpd = {};
                  if (nameParts.length) {
                    toUpd.Firstname = nameParts[0] || '';
                    toUpd.Lastname = nameParts.length > 1 ? nameParts[nameParts.length-1] : '';
                    toUpd.Middlename = nameParts.length > 2 ? nameParts.slice(1, -1).join(' ') : '';
                  }
                  if (payload.contact) toUpd.MobileNumber = payload.contact;
                  if (payload.email) toUpd.Email = payload.email;
                  if (Object.keys(toUpd).length) {
                    await window.dbUpdate(userRef, toUpd);
                    try { await ensureAuthForUser(userIdVal); } catch(e) { console.warn('ensureAuthForUser failed after user update', e); }
                  }
                }
              } catch (e) { console.warn('Failed to update user info after driver change', e); }

              // notify user
              try {
                const notifRef = window.dbRef(window.db, `users/${userIdVal}/notifications/${Date.now()}`);
                await window.dbSet(notifRef, { type: 'APPLICATION_STATUS_UPDATE', message: `Your application status is now ${appStatus}`, createdAt: Date.now(), seen: false });
              } catch (e) { console.warn('Failed to notify user', e); }

              // refresh drivers
              try { const driversSnap = await window.dbGet(window.dbRef(window.db, 'drivers')); setRawDrivers(driversSnap.val() || {}); } catch(e) {}

              // update local applicants list
              try { const updatedApplicants = [...applicants]; updatedApplicants[selectedIndex] = { ...updatedApplicants[selectedIndex], ...payload, status: appStatus, color: getStatusColor(appStatus) }; setApplicants(updatedApplicants); } catch (e) {}

              window.showAlert('Changes saved for ' + selected.name, 'success');
              closeModal();
              return;
            }

            // No driver record yet: update user and create driver record if needed
            if (userIdVal) {
              try {
                const userRef = window.dbRef(window.db, `users/${userIdVal}`);
                const nameParts = (payload.name || '').trim().split(/\s+/).filter(Boolean);
                const toUpd = {};
                if (nameParts.length) {
                  toUpd.Firstname = nameParts[0] || '';
                  toUpd.Lastname = nameParts.length > 1 ? nameParts[nameParts.length-1] : '';
                  toUpd.Middlename = nameParts.length > 2 ? nameParts.slice(1, -1).join(' ') : '';
                }
                if (payload.contact) toUpd.MobileNumber = payload.contact;
                if (typeof selected.password !== 'undefined') toUpd.Password = selected.password || '';
                if (Object.keys(toUpd).length) await window.dbUpdate(userRef, toUpd);
              } catch (e) { console.warn('Failed to update user record for applicant', e); }
            }

            // Create driver record if license/plate provided or status is APPROVED
            if (payload.license || payload.plate || appStatus === 'APPROVED') {
              try {
                const newDrvId = await claimSmallestNumericId('drivers');
                // Determine final application status when creating a new driver record.
                let finalApp = appStatus;
                try {
                  const sCheck = (appStatus || '').toString().toUpperCase();
                  if (sCheck.includes('APPROVED') && userIdVal) {
                    try {
                      const userRefCheck3 = window.dbRef(window.db, `users/${userIdVal}`);
                      const userSnapCheck3 = await window.dbGet(userRefCheck3);
                      const userObjCheck3 = userSnapCheck3.exists() ? userSnapCheck3.val() : {};
                      if (userObjCheck3 && userObjCheck3.IsActive) {
                        finalApp = 'ADDED';
                      }
                    } catch (e) { console.warn('Failed to check user IsActive when creating new driver', e); }
                  }
                } catch (e) {}

                const sFinal = (finalApp || '').toString().toUpperCase();
                const drvPayload = {
                  UserID: userIdVal || null,
                  LicenseNumber: payload.license || '',
                  TricyclePlateNumber: payload.plate || '',
                  TricycleNumber: payload.tricycleNumber || payload.plate || '',
                  FranchiseExpiry: payload.franchiseExpiry || '',
                  IsApplying: finalApp === 'ADDED' ? false : true,
                  ApplicationStatus: finalApp,
                  Status: (sFinal.includes('APPROVED') || sFinal.includes('ADDED')) ? 'Active' : 'Inactive',
                  CreatedAt: new Date().toISOString()
                };
                await window.dbSet(window.dbRef(window.db, `drivers/${newDrvId}`), drvPayload);
                if (userIdVal) await window.dbUpdate(window.dbRef(window.db, `users/${userIdVal}`), { DriverID: newDrvId, RoleID: 2 });
                try { const driversSnap = await window.dbGet(window.dbRef(window.db, 'drivers')); setRawDrivers(driversSnap.val() || {}); } catch(e) {}
                
                // Automatically create Firebase Storage folder for this driver
                // Folder name format: firstname_lastname_driverId (e.g., "JOHN_DOE_1")
                try {
                  if (window.storage && window.storageRef && window.uploadBytes) {
                    const nameParts = (name || '').trim().split(/\s+/).filter(Boolean);
                    const firstname = nameParts[0] || '';
                    const lastname = nameParts.length > 1 ? nameParts[nameParts.length-1] : '';
                    const folderName = `${firstname}_${lastname}_${newDrvId}`.replace(/\s+/g, '_').toUpperCase();
                    const folderPath = `drivers/${folderName}/.folder`;
                    const markerRef = window.storageRef(window.storage, folderPath);
                    const markerContent = `Driver: ${name}\nDriver ID: ${newDrvId}\nFolder: ${folderName}\nCreated: ${new Date().toISOString()}`;
                    const markerBlob = new Blob([markerContent], { type: 'text/plain' });
                    const uploadResult = await window.uploadBytes(markerRef, markerBlob);
                    console.log(`‚úÖ Storage folder created: ${folderName}`, uploadResult);
                  } else {
                    console.warn('Storage helpers not available:', { storage: !!window.storage, storageRef: !!window.storageRef, uploadBytes: !!window.uploadBytes });
                  }
                } catch (storageErr) {
                  console.error('‚ùå Storage Error:', storageErr);
                  console.warn('Warning: Could not create storage folder (non-critical)', storageErr);
                }
                
                window.showAlert('Applicant updated and driver record created', 'success');
                closeModal();
                return;
              } catch (e) { console.error('Failed to create driver record', e); window.showAlert('Failed to create driver record', 'error'); }
            }

            window.showAlert('Changes saved for ' + selected.name, 'success');
            closeModal();
            return;
          } catch (err) {
            console.error('Error updating applicant:', err);
            window.showAlert('Error saving changes: ' + (err.message || err), 'error');
            return;
          }
        }
      };

      const approveAndAdd = async () => {
        if (!selected || !selected.id) return;
        if (!window.adminAllowed) {
          window.showAlert('Admin session unavailable. Sign in with an admin account or enable anonymous admin sign-in.', 'error');
          return;
        }
        if (!window.db || !window.dbRef || !window.dbPush || !window.dbGet || !window.dbUpdate) {
          window.showAlert('Database helpers not available', 'error');
          return;
        }

        setIsProcessing(true);
        try {
          if (!window.dbRunTransaction || !window.dbRef || !window.dbSet || !window.dbGet || !window.dbUpdate) {
            throw new Error('Required DB helpers not available');
          }

          const normalize = (s) => (s||'').toString().toUpperCase().replace(/[^A-Z0-9]/g, '');
          const licenseNorm = normalize(selected.license);

          // Check drivers for duplicate license
          const driversSnap = await window.dbGet(window.dbRef(window.db, 'drivers'));
          const driversVal = driversSnap.val() || {};
          for (const [k, d] of Object.entries(driversVal)) {
            const dLicense = normalize(d.LicenseNumber || d.license || '');
            if (dLicense && dLicense === licenseNorm) {
              window.showAlert('A driver with the same license already exists. Aborting add.', 'error');
              setIsProcessing(false);
              return;
            }
          }

          // Claim smallest available numeric IDs and create records (reuses gaps)
          const userId = await claimSmallestNumericId('users');

          // Create user record
          const fullName = (selected.name || '').trim();
          const parts = fullName.split(' ').filter(Boolean);
          const firstname = parts.shift() || fullName;
          const lastname = parts.join('') || '';

          const userPayload = {
            Firstname: firstname,
            Lastname: lastname,
            MobileNumber: selected.contact || '',
            Email: selected.email || '',
            Role: 'Driver',
            // RoleID numeric for driver role (use 2 as driver code)
            RoleID: 2,
            // store admin-provided password in plain text (per request)
            Password: selected.password || '',
            CreatedAt: new Date().toISOString(),
            // Do not activate user here; activation happens in Driver Management
            IsActive: false
          };

          // userId is now a NUMBER from claimSmallestNumericId, use it directly
          const userRef = window.dbRef(window.db, `users/${userId}`);
          console.log('approveAndAdd: writing new user to DB, userId =', userId, 'with email =', userPayload.Email, 'password =', userPayload.Password ? '***' : 'MISSING');
          await window.dbSet(userRef, userPayload);
          console.log('approveAndAdd: user written to DB');

          // Create Firebase Auth account immediately with the email/password we just wrote
          // Do this in parallel with other operations (don't wait for DB propagation)
          try {
            console.log('approveAndAdd: creating Firebase Auth account for', userPayload.Email);
            const authUid = await createAuthUser(userPayload.Email, userPayload.Password);
            if (authUid) {
              console.log('approveAndAdd: Auth account created successfully, UID =', authUid);
              // Write the Auth UID back to the user record
              try {
                await window.dbUpdate(userRef, { AuthUID: authUid });
                console.log('approveAndAdd: AuthUID persisted to user record');
              } catch(e) {
                console.warn('approveAndAdd: failed to persist AuthUID to DB', e);
              }
            } else {
              console.warn('approveAndAdd: createAuthUser returned null/falsy');
            }
          } catch(e) {
            console.warn('approveAndAdd: Auth account creation error', e);
          }

          const driverId = await claimSmallestNumericId('drivers');

          // Create driver record
          const driverPayload = {
            UserID: userId, // Store as number, not string
            LicenseNumber: selected.license || '',
            TricyclePlateNumber: selected.plate || '',
            TricycleNumber: selected.tricycleNumber || selected.plate || '',
            ApplicationStatus: 'APPROVED',
            // Driver-level IsActive/IsOnline are not stored here. User record owns IsActive.
            CreatedAt: new Date().toISOString()
          };

          // driverId is now a NUMBER from claimSmallestNumericId, use it directly
          const driverRef = window.dbRef(window.db, `drivers/${driverId}`);
          await window.dbSet(driverRef, driverPayload);

          // Update user record to include DriverID reference
          try {
            await window.dbUpdate(userRef, { DriverID: driverId, RoleID: 2 });
          } catch (e) {
            console.warn('Failed to update user with DriverID/RoleID after adding driver', e);
          }

          // (no explicit allocation writes here ‚Äî reservation is handled inside claimSmallestNumericId)

          // Update local UI state (no longer writing to legacy `applications/` node)
          const payload = {
            UserID: userId,
            DriverID: driverId,
            ApplicationStatus: 'APPROVED',
            LicenseNumber: selected.license || '',
            TricyclePlateNumber: selected.plate || '',
            TricycleNumber: selected.tricycleNumber || selected.plate || '',
            CreatedAt: new Date().toISOString()
          };
          const updatedApplicants = [...applicants];
          if (typeof selectedIndex === 'number' && updatedApplicants[selectedIndex]) {
            updatedApplicants[selectedIndex] = { ...updatedApplicants[selectedIndex], ...payload };
            setApplicants(updatedApplicants);
          }

          window.showAlert('Applicant approved and added as driver', 'success');
          closeModal();
        } catch (err) {
          console.error('Error approving and adding driver:', err);
          window.showAlert('Error: ' + (err.message || err), 'error');
        } finally {
          setIsProcessing(false);
        }
      };

      const rawSegment = window.location.pathname.split("/").pop() || window.location.href.split("/").pop() || '';
      const normalize = (s) => decodeURIComponent((s || '').toString()).toLowerCase().trim();
      const currentPage = normalize(rawSegment);

      const getLinkClass = (page) => {
        const isActive = currentPage === normalize(page);
        return "flex items-center gap-3 px-4 py-3 rounded-lg transition-colors " +
          (isActive ? "bg-yellow-500 text-gray-900 font-semibold" : "text-gray-300 hover:bg-gray-700");
      };

      // If user is not authorized, show access denied message
      if (!window.adminAllowed && window.currentUser !== undefined && window.currentUser === null) {
        return (
          <div className="flex min-h-screen bg-[#0a0e1a] items-center justify-center">
            <div className="bg-[#1e2538] p-12 rounded-xl text-center max-w-md">
              <h1 className="text-3xl font-bold text-red-500 mb-4">Access Denied</h1>
              <p className="text-gray-300 mb-6">You do not have permission to access this admin dashboard.</p>
              <p className="text-gray-400 text-sm mb-8">Only users with admin role (RoleID = 4) can access this page.</p>
              <a href="log in.html" className="bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-6 rounded-lg transition">
                Return to Login
              </a>
            </div>
          </div>
        );
      }

      // Show loading message while authentication is being checked
      if (window.adminAllowed === false && window.currentUser === undefined) {
        return (
          <div className="flex min-h-screen bg-[#0a0e1a] items-center justify-center">
            <div className="bg-[#1e2538] p-12 rounded-xl text-center">
              <p className="text-gray-300">Verifying admin credentials...</p>
            </div>
          </div>
        );
      }

      return (
        <div className="flex min-h-screen bg-[#0a0e1a]">

          {/* Sidebar */}
          <aside className="w-72 bg-[#0e1420] text-white p-6 flex flex-col border-r border-gray-900">
            <div className="flex items-center gap-3 mb-10">
              <div className="w-14 h-14 rounded-2xl flex items-center justify-center overflow-hidden">
                <img src="tricy.png" alt="Pasakay" className="w-full h-full object-cover bg-yellow-500 p-1" />
              </div>
              <div>
                <h1 className="text-2xl font-bold text-yellow-500">PASAKAY</h1>
                <p className="text-sm text-gray-400">Admin Dashboard</p>
              </div>
            </div>

            <nav className="flex flex-col gap-2">
              <a href="dashboard.html" className={getLinkClass("dashboard.html")}>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6" />
                </svg>
                Dashboard
              </a>
              <a href="driver management.html" className={getLinkClass("driver management.html")}>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                </svg>
                Drivers
              </a>
              <a href="passenger management.html" className={getLinkClass("passenger management.html")}>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z" />
                </svg>
                Passengers
              </a>
              <a href="Driver application.html" className={getLinkClass("Driver application.html")}>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                </svg>
                Membership
              </a>
              <a href="booking management.html" className={getLinkClass("booking management.html")}>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
                </svg>
                Bookings
              </a>
              <a href="Logs.html" className={getLinkClass("Logs.html")}>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                </svg>
                Logs
              </a>
              <a href="Fare Matrix.html" className={getLinkClass("Fare Matrix.html")}>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
                Fare Matrix
              </a>
              <a href="log out.html" className={getLinkClass("log out.html")}>
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M17 16l4-4m0 0l-4-4m4 4H7m6 4v1a3 3 0 01-3 3H6a3 3 0 01-3-3V7a3 3 0 013-3h4a3 3 0 013 3v1" />
                </svg>
                Log out
              </a>
            </nav>
          </aside>

          {/* Main Content */}
          <main className="flex-1 bg-[#1a202e] p-8">

            <header className="flex justify-between items-center mb-8">
              <h2 className="text-3xl font-bold text-white">Driver Application</h2>
              <div className="flex items-center gap-3 bg-yellow-500 px-4 py-2 rounded-lg">
                <div className="w-10 h-10 bg-gray-900 text-yellow-500 rounded-full flex items-center justify-center font-bold text-lg">
                  A
                </div>
                <span className="font-semibold text-gray-900">Admin</span>
              </div>
            </header>

              {/* Add Driver Modal */}
              {showAddDriverModal && (
                <div className="fixed inset-0 bg-black bg-opacity-80 flex justify-center items-center z-50">
                  <div className="bg-[#1e2538] p-8 rounded-xl w-[520px]">
                    <div className="flex justify-between items-center mb-4">
                      <h3 className="text-2xl font-bold text-white">Add New Driver (Quick)</h3>
                      <button onClick={() => setShowAddDriverModal(false)} className="text-gray-400 hover:text-white text-2xl font-light">√ó</button>
                    </div>
                    <AddSimpleDriverForm onClose={() => setShowAddDriverModal(false)} ensureAuthForUser={ensureAuthForUser} />
                  </div>
                </div>
              )}

            {/* Applicants List */}
            <div className="bg-[#1e2538] p-8 rounded-xl">
              <div className="flex justify-between items-center mb-6">
                <h3 className="text-2xl font-bold text-white">Driver Applicants</h3>
                <button onClick={() => setShowAddDriverModal(true)} className="bg-green-600 hover:bg-green-700 px-4 py-2 rounded text-white text-sm font-semibold">Add Applicant</button>
              </div>

              <div className="flex items-center gap-4 mb-4">
                <select value={statusFilter} onChange={(e) => setStatusFilter(e.target.value)} className="px-3 py-2 rounded bg-[#252d42] text-white border border-gray-700">
                  <option value="ALL">All Statuses</option>
                  <option value="TO REVIEW">To Review</option>
                  <option value="APPROVED">Approved</option>
                  <option value="EXPIRED">Expired</option>
                  <option value="REJECTED">Rejected</option>
                </select>
                <input placeholder="Search applicants..." value={searchQuery} onChange={(e) => setSearchQuery(e.target.value)} className="px-3 py-2 rounded bg-[#252d42] text-white border border-gray-700 flex-1" />
              </div>

              <div className="space-y-4 applicants-scroll" style={{
                maxHeight: '600px',
                overflowY: 'auto',
                scrollbarColor: '#2d3548 #252d42',
                scrollbarWidth: 'thin',
                paddingRight: '8px'
              }}>
                {applicants.filter(a => {
                  if (statusFilter !== 'ALL' && a.status !== statusFilter) return false;
                  if (searchQuery && searchQuery.trim()) {
                    const q = searchQuery.toLowerCase();
                    return (a.name||'').toLowerCase().includes(q) || (a.contact||'').toLowerCase().includes(q) || (a.license||'').toLowerCase().includes(q);
                  }
                  return true;
                }).map((applicant, index) => (
                  <div key={applicant.id || index} className="flex justify-between items-center bg-[#252d42] p-6 rounded-lg hover:bg-[#2d3548] transition-colors">
                    <div className="flex items-center gap-4">
                      <div className={`w-12 h-12 rounded-full ${applicant.color} flex items-center justify-center font-bold text-white text-lg`}>
                        {applicant.initials}
                      </div>
                      <div>
                        <h4 className="font-bold text-white text-lg">{applicant.name}</h4>
                        <p className="text-sm text-gray-400">
                          Contact: {stripPhonePrefix(applicant.contact)} | License: {applicant.license} | Plate: {applicant.plate}
                        </p>
                      </div>
                    </div>
                    <div className="flex items-center gap-3">
                      <span className={`${getStatusColor(applicant.status)} px-4 py-2 rounded-lg text-sm font-bold text-white`}>
                        {applicant.status}
                      </span>
                      <button
                        onClick={() => openModal(index)}
                        className="bg-yellow-500 hover:bg-yellow-600 px-4 py-2 rounded-lg text-sm font-semibold text-gray-900 flex items-center gap-2"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                        </svg>
                        Edit
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          </main>

          {/* MODAL */}
          {showModal && selected && (
            <div className="fixed inset-0 bg-black bg-opacity-80 flex justify-center items-center z-50 overflow-y-auto py-8">
              <div className="bg-[#1e2538] p-8 rounded-xl w-[1000px] max-h-[90vh] overflow-y-auto">

                {/* Header */}
                <div className="flex justify-between items-center mb-6">
                  <h3 className="text-2xl font-bold text-white">Applicant Review</h3>
                  <button onClick={closeModal} className="text-gray-400 hover:text-white text-3xl font-light">
                    &times;
                  </button>
                </div>

                {/* Inputs */}
                <div className="grid grid-cols-2 gap-6 mb-8">
                  <Input label="Full Name" name="name" value={selected.name} onChange={handleInputChange} />
                  <Input label="Email" name="email" value={selected.email || ''} onChange={handleInputChange} />
                  <div className="flex flex-col">
                    <label className="text-sm text-gray-300 mb-2 font-medium">Contact Number (11 digits)</label>
                    <div className="flex">
                      <div className="inline-flex items-center px-3 rounded-l-lg bg-[#1b2333] text-white border border-r-0 border-gray-700">+63</div>
                      <input
                        name="contact"
                        value={selected.contact || ''}
                        onChange={(e) => {
                          const raw = e.target.value.replace(/\D/g, '').slice(0,11);
                          handleInputChange({ target: { name: 'contact', value: raw } });
                        }}
                        maxLength="11"
                        placeholder="09123456789"
                        className="w-full px-4 py-3 rounded-r-lg bg-[#252d42] text-white border border-gray-700 focus:border-yellow-500 focus:outline-none"
                      />
                    </div>
                    <p className="text-xs text-gray-400 mt-1">Format: +63 followed by 11 digits</p>
                  </div>
                  <div className="flex flex-col">
                    <label className="text-sm text-gray-300 mb-2 font-medium">Password</label>
                    <div className="relative">
                      <input
                        name="password"
                        type={selectedPasswordVisible ? 'text' : 'password'}
                        value={selected.password || ''}
                        onChange={(e) => handleInputChange({ target: { name: 'password', value: e.target.value } })}
                        placeholder="Enter password (stored as plain text)"
                        className="w-full px-4 py-3 rounded-lg bg-[#252d42] text-white border border-gray-700 focus:border-yellow-500 focus:outline-none"
                      />
                      <button
                        type="button"
                        onClick={() => setSelectedPasswordVisible(v => !v)}
                        className="absolute right-2 top-1/2 -translate-y-1/2 text-gray-300 hover:text-white"
                        aria-label="Toggle password visibility"
                      >
                        {selectedPasswordVisible ? (
                          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-5.523 0-10-4.477-10-10 0-1.05.165-2.063.469-3.013M3 3l18 18"/></svg>
                        ) : (
                          <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/></svg>
                        )}
                      </button>
                    </div>
                    <p className="text-xs text-gray-400 mt-1">Password is stored in users/&lt;id&gt;/Password as plain text.</p>
                  </div>
                  <div className="flex flex-col">
                    <label className="text-sm text-gray-300 mb-2 font-medium">License Number</label>
                    <input
                      name="license"
                      value={selected.license}
                      onChange={(e) => {
                        const raw = e.target.value.replace(/[^A-Za-z0-9\-]/g, '');
                        handleInputChange({ target: { name: 'license', value: raw } });
                      }}
                      onBlur={() => {
                        const formatted = formatLicense(selected.license);
                        handleInputChange({ target: { name: 'license', value: formatted } });
                      }}
                      placeholder="e.g. A01-23-456789"
                      className="px-4 py-3 rounded-lg bg-[#252d42] text-white border border-gray-700 focus:border-yellow-500 focus:outline-none"
                    />
                  </div>
                  <div className="flex flex-col">
                    <label className="text-sm text-gray-300 mb-2 font-medium">Registered Date</label>
                    <input
                      name="registeredDate"
                      value={selected.registeredDate}
                      onChange={handleInputChange}
                      placeholder="YYYY-MM-DD HH:MM:SS"
                      className="px-4 py-3 rounded-lg bg-[#252d42] text-white border border-gray-700 focus:border-yellow-500 focus:outline-none"
                    />
                  </div>
                  <Input label="Tricycle Plate Number" name="plate" value={selected.plate} onChange={handleInputChange} />
                  <Input label="Tricycle Number" name="tricycleNumber" value={selected.tricycleNumber} onChange={handleInputChange} />
                  <Input label="Franchise Expiry" name="franchiseExpiry" value={selected.franchiseExpiry} onChange={handleInputChange} />

                  <div>
                    <div className="flex items-center gap-3">
                      <label className="text-sm text-gray-300 font-medium whitespace-nowrap">Application Status</label>
                      {selected && selected.displayStatus === 'ADDED' && (
                        <span className="inline-flex items-center ml-2 px-2 py-0.5 text-xs font-semibold rounded bg-blue-600 text-white">
                          Display: ADDED
                        </span>
                      )}
                    </div>
                    <select
                      name="ApplicationStatus"
                      value={selected.ApplicationStatus || selected.Application_Status || selected.status || 'TO REVIEW'}
                      // keep a small gap between label row and select
                      style={{ marginTop: '6px' }}
                      onChange={handleInputChange}
                      className="w-full px-4 py-3 rounded-lg bg-[#252d42] text-white border border-gray-700 focus:border-yellow-500 focus:outline-none"
                    >
                      <option value="TO REVIEW">To Review</option>
                      <option value="APPROVED">Approved</option>
                      <option value="REJECTED">Rejected</option>
                      <option value="EXPIRED">Expired</option>
                    </select>
                  </div>
                </div>

                {/* FILE SUBMISSION TABLE */}
                <h4 className="text-xl font-bold mb-4 text-white">Submitted Documents</h4>

                <div className="overflow-x-auto mb-8">
                  <table className="w-full border-collapse">
                    <thead>
                      <tr className="bg-[#252d42]">
                        <th className="px-6 py-4 text-left text-white font-semibold">Requirement</th>
                        <th className="px-6 py-4 text-left text-white font-semibold">Date Submitted</th>
                        <th className="px-6 py-4 text-left text-white font-semibold">File</th>
                      </tr>
                    </thead>
                    <tbody>
                      <FileRow
                        requirement="Driver's License"
                        documentType="license"
                        driverId={selected.drvId}
                        doc={selected.documents?.license}
                        missing={!selected.documents?.license}
                      />
                      <FileRow
                        requirement="NBI Clearance"
                        documentType="nbi"
                        driverId={selected.drvId}
                        doc={selected.documents?.nbi}
                        missing={!selected.documents?.nbi}
                      />
                      <FileRow
                        requirement="QC ID"
                        documentType="qc"
                        driverId={selected.drvId}
                        doc={selected.documents?.qc}
                        missing={!selected.documents?.qc}
                      />
                      <FileRow
                        requirement="Drug Test Result"
                        documentType="drug"
                        driverId={selected.drvId}
                        doc={selected.documents?.drug}
                        missing={!selected.documents?.drug}
                      />
                    </tbody>
                  </table>
                </div>

                {/* Action Buttons */}
                <div className="flex justify-between">
                  <button onClick={closeModal} className="bg-red-600 hover:bg-red-700 px-8 py-3 rounded-lg font-semibold text-white">
                    Cancel
                  </button>
                  <div className="flex items-center gap-3">
                    <button onClick={saveChanges} className="bg-green-600 hover:bg-green-700 px-8 py-3 rounded-lg font-semibold text-white">
                      Save Changes
                    </button>
                  </div>
                </div>

              </div>
            </div>
          )}
        </div>
      );
    };

    const Input = ({ label, name, value, onChange }) => (
      <div className="flex flex-col">
        <label className="text-sm text-gray-300 mb-2 font-medium">{label}</label>
        <input
          name={name}
          value={value || ''}
          onChange={onChange}
          className="px-4 py-3 rounded-lg bg-[#252d42] text-white border border-gray-700 focus:border-yellow-500 focus:outline-none"
        />
      </div>
    );

    const AddSimpleDriverForm = ({ onClose, ensureAuthForUser }) => {
      const [name, setName] = React.useState('');
      const [email, setEmail] = React.useState('');
      const [contact, setContact] = React.useState('');
      const [password, setPassword] = React.useState('');
      const [showPassword, setShowPassword] = React.useState(false);
      const [nameError, setNameError] = React.useState('');
      const [emailError, setEmailError] = React.useState('');
      const [contactError, setContactError] = React.useState('');
      const [isSaving, setIsSaving] = React.useState(false);

      // Real-time validation for name field
      const handleNameChange = (e) => {
        const value = e.target.value.replace(/[^a-zA-Z\s\-']/g, '');
        setName(value);
        
        // Real-time error checking
        if (value && /\d/.test(value)) {
          setNameError('Numbers are not allowed in name');
        } else if (!value) {
          setNameError('Full name is required');
        } else {
          setNameError('');
        }
      };

      // Real-time validation for email field
      const handleEmailChange = (e) => {
        const value = e.target.value.trim().toLowerCase();
        setEmail(value);
        
        // Real-time error checking
        if (!value) {
          setEmailError('Email is required');
        } else {
          let emailToCheck = value;
          if (!emailToCheck.includes('@')) {
            emailToCheck = emailToCheck + '@gmail.com';
          }
          const domain = emailToCheck.split('@')[1] || '';
          if (domain !== 'gmail.com') {
            setEmailError('Email must be a gmail.com address');
          } else {
            setEmailError('');
          }
        }
      };

      // Real-time validation for contact field
      const handleContactChange = (e) => {
        const value = e.target.value.replace(/\D/g, '').slice(0,11);
        setContact(value);
        
        // Real-time error checking
        if (value.length === 0) {
          setContactError('Phone number is required');
        } else if (value.length < 11) {
          setContactError(`${11 - value.length} more digit${11 - value.length !== 1 ? 's' : ''} needed`);
        } else if (value.length === 11) {
          setContactError('');
        }
      };

      const validate = () => {
        let ok = true;
        // Name: no digits
        if (!name || /\d/.test(name)) {
          setNameError('Full name is required and cannot contain numbers');
          ok = false;
        } else setNameError('');

        // Email: enforce gmail.com domain (append if user forgot domain)
        let e = (email || '').toString().trim().toLowerCase();
        if (!e) {
          setEmailError('Email is required'); ok = false;
        } else {
          if (!e.includes('@')) e = e + '@gmail.com';
          const domain = e.split('@')[1] || '';
          if (domain !== 'gmail.com') { setEmailError('Email must be a gmail.com address'); ok = false; }
          else setEmailError('');
        }

        // Contact: must be 11 digits (displayed with +63 prefix, but only 11 digits needed)
        const phoneRaw = (contact || '').toString().replace(/\D/g, '').slice(0,11);
        if (phoneRaw.length !== 11) { setContactError('Phone number must be exactly 11 digits'); ok = false; } else setContactError('');

        // Return phone with +63 prefix format
        const fullPhone = '+63' + phoneRaw;
        return { ok, emailPrepared: e, phoneRaw: fullPhone };
      };

      const handleSubmit = async () => {
        const { ok, emailPrepared, phoneRaw } = validate();
        if (!ok) return;
        if (!window.db || !window.dbRef || !window.dbSet || !window.dbRunTransaction) {
          window.showAlert('Database not available', 'error');
          return;
        }
        if (!window.adminAllowed) {
          window.showAlert('Admin session unavailable. Sign in with an admin account or enable anonymous admin sign-in.', 'error');
          return;
        }
        setIsSaving(true);
        try {
          // Use push() keys for quick-add to avoid creating allocations entries
          // split name
          const parts = (name || '').trim().split(/\s+/).filter(Boolean);
          const firstname = parts[0] || '';
          const lastname = parts.length > 1 ? parts[parts.length-1] : '';
          const middlename = parts.length > 2 ? parts.slice(1, -1).join(' ') : '';
          const userObj = {
            Firstname: firstname,
            Middlename: middlename,
            Lastname: lastname,
            Email: emailPrepared,
            MobileNumber: phoneRaw,
            Role: 'Driver',
            RoleID: 2,
            Password: password || '',
            CreatedAt: new Date().toISOString(),
            // New applicant: IsActive should be false until approved
            IsActive: false
          };
          // create user with numeric id (claim smallest available) instead of a push key
          // userId is now a NUMBER from claimSmallestNumericId, use it directly
          const userId = await claimSmallestNumericId('users');
          const userRef = window.dbRef(window.db, `users/${userId}`);
          console.log('AddSimpleDriverForm: writing new applicant to DB, userId =', userId, 'with email =', userObj.Email, 'password =', userObj.Password ? '***' : 'MISSING');
          await window.dbSet(userRef, userObj);
          console.log('AddSimpleDriverForm: applicant written to DB');

          // Create Firebase Auth account immediately with the email/password we just wrote
          // Do this in parallel with other operations (don't wait for DB propagation)
          try {
            console.log('AddSimpleDriverForm: creating Firebase Auth account for', userObj.Email);
            const authUid = await createAuthUser(userObj.Email, userObj.Password);
            if (authUid) {
              console.log('AddSimpleDriverForm: Auth account created successfully, UID =', authUid);
              // Write the Auth UID back to the user record
              try {
                await window.dbUpdate(userRef, { AuthUID: authUid });
                console.log('AddSimpleDriverForm: AuthUID persisted to user record');
              } catch(e) {
                console.warn('AddSimpleDriverForm: failed to persist AuthUID to DB', e);
              }
            } else {
              console.warn('AddSimpleDriverForm: createAuthUser returned null/falsy');
            }
          } catch(e) {
            console.warn('AddSimpleDriverForm: Auth account creation error', e);
          }

          // Also create a drivers/ record for this applicant (IsApplying: true, ApplicationStatus: TO REVIEW)
          const driverId = await claimSmallestNumericId('drivers');
          const driverRef = window.dbRef(window.db, `drivers/${driverId}`);
          const driverObj = {
            UserID: userId,
            LicenseNumber: '',
            TricyclePlateNumber: '',
            TricycleNumber: '',
            FranchiseExpiry: '',
            IsApplying: true,
            ApplicationStatus: 'TO REVIEW',
            CreatedAt: new Date().toISOString()
          };
          await window.dbSet(driverRef, driverObj);

          // Automatically create Firebase Storage folder structure for this driver
          // Folder name format: firstname_lastname_driverId (e.g., "JOHN_DOE_1")
          try {
            if (window.storage && window.storageRef && window.uploadBytes) {
              // Create folder name: firstname_lastname_driverId
              const folderName = `${firstname}_${lastname}_${driverId}`.replace(/\s+/g, '_').toUpperCase();
              const folderPath = `drivers/${folderName}/.folder`;
              const markerRef = window.storageRef(window.storage, folderPath);
              const markerContent = `Driver: ${name}\nDriver ID: ${driverId}\nFolder: ${folderName}\nCreated: ${new Date().toISOString()}`;
              const markerBlob = new Blob([markerContent], { type: 'text/plain' });
              const uploadResult = await window.uploadBytes(markerRef, markerBlob);
              console.log(`‚úÖ Storage folder created: ${folderName}`, uploadResult);
            } else {
              console.warn('Storage helpers not available:', { storage: !!window.storage, storageRef: !!window.storageRef, uploadBytes: !!window.uploadBytes });
            }
          } catch (storageErr) {
            console.error('‚ùå Storage Error:', storageErr);
            console.warn('Warning: Could not create storage folder (non-critical)', storageErr);
            // Don't fail the entire operation if storage folder creation fails
          }

          window.showAlert('Driver applicant added and marked as TO REVIEW. Storage folder created.', 'success');
          onClose();
        } catch (err) {
          console.error('Error adding driver applicant', err);
          window.showAlert('Error: ' + (err && err.message ? err.message : err), 'error');
        } finally {
          setIsSaving(false);
        }
      };

      return (
        <div className="space-y-4">
          <div>
            <label className="text-sm text-gray-300 mb-2 font-medium">Full Name</label>
            <input 
              value={name} 
              onChange={handleNameChange} 
              placeholder="Enter full name (letters, spaces, hyphens only)"
              className={`w-full px-4 py-3 rounded-lg bg-[#252d42] text-white border ${nameError ? 'border-red-500' : 'border-gray-700'} focus:outline-none transition`}
            />
            {nameError && <p className="text-sm text-red-400 mt-1">{nameError}</p>}
          </div>
          <div>
            <label className="text-sm text-gray-300 mb-2 font-medium">Email</label>
            <input 
              value={email} 
              onChange={handleEmailChange} 
              placeholder="example@gmail.com (gmail.com only)"
              className={`w-full px-4 py-3 rounded-lg bg-[#252d42] text-white border ${emailError ? 'border-red-500' : 'border-gray-700'} focus:outline-none transition`}
            />
            {emailError && <p className="text-sm text-red-400 mt-1">{emailError}</p>}
          </div>
          <div>
            <label className="text-sm text-gray-300 mb-2 font-medium">Contact Number (11 digits)</label>
            <div className="flex">
              <div className="inline-flex items-center px-3 rounded-l-lg bg-[#1b2333] text-white border border-r-0 border-gray-700">+63</div>
              <input 
                value={contact} 
                onChange={handleContactChange} 
                placeholder="09123456789" 
                maxLength="11" 
                className={`w-full px-4 py-3 rounded-r-lg bg-[#252d42] text-white border ${contactError ? 'border-red-500' : 'border-gray-700'} focus:outline-none transition`}
              />
            </div>
            <p className="text-xs text-gray-400 mt-1">Format: +63 followed by 11 digits</p>
            {contactError && <p className="text-sm text-red-400 mt-1">{contactError}</p>}
          </div>
          <div>
            <label className="text-sm text-gray-300 mb-2 font-medium">Password</label>
            <div className="relative">
              <input
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Set a password (stored plain)"
                type={showPassword ? 'text' : 'password'}
                className="w-full px-4 py-3 rounded-lg bg-[#252d42] text-white border border-gray-700 focus:outline-none"
              />
              <button type="button" onClick={() => setShowPassword(v => !v)} className="absolute right-2 top-1/2 -translate-y-1/2 text-gray-300 hover:text-white">
                {showPassword ? (
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-5.523 0-10-4.477-10-10 0-1.05.165-2.063.469-3.013M3 3l18 18"/></svg>
                ) : (
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"/></svg>
                )}
              </button>
            </div>
            <p className="text-xs text-gray-400 mt-1">Password will be written to `users/&lt;id&gt;/Password` as plain text.</p>
          </div>
          <div className="flex justify-end gap-3 mt-4">
            <button onClick={onClose} className="bg-gray-600 hover:bg-gray-700 px-6 py-2 rounded text-white">Cancel</button>
            <button onClick={handleSubmit} disabled={isSaving || nameError || emailError || contactError} className={`px-6 py-2 rounded font-semibold text-white ${isSaving || nameError || emailError || contactError ? 'bg-gray-600 cursor-not-allowed' : 'bg-yellow-500 hover:bg-yellow-600'}`}>
              {isSaving ? 'Adding‚Ä¶' : 'Add Applicant'}
            </button>
          </div>
        </div>
      );
    };

    const FileRow = ({ requirement, documentType, driverId, doc, missing }) => {
      // documentType: 'license', 'nbi', 'qc', 'drug'
      // doc: { documentType, fileName, downloadUrl, size, fileType }
      const [modifiedDate, setModifiedDate] = React.useState('Fetching...');
      
      // Fetch file metadata from Firebase Storage to get the modified date
      React.useEffect(() => {
        if (!doc || !doc.downloadUrl) return;
        
        const fetchFileMetadata = async () => {
          try {
            // Parse the download URL to extract the storage path
            const url = new URL(doc.downloadUrl);
            // Firebase storage URL format: https://firebasestorage.googleapis.com/v0/b/{bucket}/o/{path}?alt=media&token={token}
            const pathMatch = url.pathname.match(/\/o\/(.*?)(?:\?|$)/);
            if (!pathMatch) {
              setModifiedDate('N/A');
              return;
            }
            
            const storagePath = decodeURIComponent(pathMatch[1]);
            
            // Import and use getMetadata from Firebase Storage
            // Note: This requires getMetadata to be available from the Firebase SDK
            try {
              // Dynamically import getMetadata if not already available
              if (window.getMetadata) {
                const fileRef = window.storageRef(window.storage, storagePath);
                const metadata = await window.getMetadata(fileRef);
                
                if (metadata && metadata.timeCreated) {
                  const uploadDate = new Date(metadata.timeCreated).toLocaleDateString();
                  setModifiedDate(uploadDate);
                } else if (metadata && metadata.updated) {
                  const uploadDate = new Date(metadata.updated).toLocaleDateString();
                  setModifiedDate(uploadDate);
                } else {
                  setModifiedDate('N/A');
                }
              } else {
                // Fallback: try to fetch metadata via REST API
                const bucket = 'pasakay-project-ph.firebasestorage.app';
                const metadataUrl = `https://www.googleapis.com/storage/v1/b/${bucket}/o/${encodeURIComponent(storagePath)}?alt=json&key=${window.firebaseApiKey}`;
                
                const response = await fetch(metadataUrl);
                if (!response.ok) {
                  console.warn('Failed to fetch metadata via REST API');
                  setModifiedDate('N/A');
                  return;
                }
                
                const metadata = await response.json();
                if (metadata && metadata.timeCreated) {
                  const uploadDate = new Date(metadata.timeCreated).toLocaleDateString();
                  setModifiedDate(uploadDate);
                } else if (metadata && metadata.updated) {
                  const uploadDate = new Date(metadata.updated).toLocaleDateString();
                  setModifiedDate(uploadDate);
                } else {
                  setModifiedDate('N/A');
                }
              }
            } catch (metadataErr) {
              console.warn('Error fetching Firebase Storage metadata:', metadataErr);
              setModifiedDate('N/A');
            }
          } catch (err) {
            console.warn('Failed to parse file URL or fetch metadata:', err);
            setModifiedDate('N/A');
          }
        };
        
        fetchFileMetadata();
      }, [doc]);
      
      if (missing || !doc) {
        return (
          <tr className="bg-[#151b28] hover:bg-[#1a202e]">
            <td className="px-6 py-4 text-gray-300 font-medium">{requirement}</td>
            <td className="px-6 py-4 text-center" colSpan="2">
              <div className="flex items-center justify-center gap-2">
                <span className="bg-red-600 px-4 py-2 rounded-lg text-sm font-bold text-white">NOT SUBMITTED</span>
              </div>
            </td>
          </tr>
        );
      }

      const fileSize = doc.size ? (doc.size / 1024 / 1024).toFixed(2) + ' MB' : 'Unknown';
      const fileType = doc.fileType || getFileType(doc.downloadUrl || doc.fileName || '');
      
      // Determine icon based on file type
      const getFileIcon = () => {
        switch(fileType) {
          case 'pdf':
            return (
              <svg className="w-6 h-6 text-red-500" fill="currentColor" viewBox="0 0 20 20">
                <path d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm9 8a1 1 0 11-2 0 1 1 0 012 0zm-4 2a1 1 0 100-2 1 1 0 000 2zm8-2a1 1 0 11-2 0 1 1 0 012 0z"/>
              </svg>
            );
          case 'image':
            return (
              <svg className="w-6 h-6 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
                <path fillRule="evenodd" d="M4 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z" clipRule="evenodd"/>
              </svg>
            );
          case 'document':
            return (
              <svg className="w-6 h-6 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                <path d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z"/>
              </svg>
            );
          default:
            return (
              <svg className="w-6 h-6 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
                <path d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4z"/>
              </svg>
            );
        }
      };

      const displayName = doc.fileName || getFileNameFromUrl(doc.downloadUrl || '');

      // Helper: show a modal preview (image or PDF) with zoom and pan support
      const showPreview = (url, type) => {
        if (!url) return;
        let modal = document.getElementById('file-preview-modal');
        if (!modal) {
          modal = document.createElement('div');
          modal.id = 'file-preview-modal';
          modal.style.position = 'fixed';
          modal.style.inset = '0';
          modal.style.display = 'flex';
          modal.style.alignItems = 'center';
          modal.style.justifyContent = 'center';
          modal.style.background = 'rgba(0,0,0,0.6)';
          modal.style.zIndex = 9999;
          modal.innerHTML = `
            <div id="file-preview-container" style="background:#0b1220;padding:12px;border-radius:8px;max-width:90%;max-height:90%;box-shadow:0 10px 30px rgba(0,0,0,0.6);width:90%;">
              <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;gap:12px;">
                <div style="color:#fef3c7;font-weight:600;">Preview</div>
                <div id="file-preview-controls" style="display:flex;align-items:center;gap:8px;margin-left:8px;">
                  <button id="zoom-out" style="background:#1f2937;border:none;padding:6px 8px;color:#fef3c7;border-radius:6px;cursor:pointer;">-</button>
                  <div id="zoom-level" style="color:#fef3c7;min-width:48px;text-align:center;">100%</div>
                  <button id="zoom-in" style="background:#1f2937;border:none;padding:6px 8px;color:#fef3c7;border-radius:6px;cursor:pointer;">+</button>
                  <button id="zoom-reset" style="background:#111827;border:none;padding:6px 8px;color:#fef3c7;border-radius:6px;cursor:pointer;">Reset</button>
                </div>
                <button id="file-preview-close" style="background:transparent;border:none;color:#fef3c7;font-size:18px;cursor:pointer;">‚úï</button>
              </div>
              <div id="file-preview-body" style="width:100%;height:80vh;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative;border-radius:6px;background:#000;"></div>
            </div>
          `;
          document.body.appendChild(modal);
          document.getElementById('file-preview-close').addEventListener('click', () => { modal.remove(); });
          modal.addEventListener('click', (ev) => {
            if (ev.target === modal) modal.remove();
          });
        }

        const body = modal.querySelector('#file-preview-body');
        body.innerHTML = '';

        // State for zoom/pan stored on modal element
        modal._scale = modal._scale || 1;
        modal._translateX = modal._translateX || 0;
        modal._translateY = modal._translateY || 0;

        const controls = modal.querySelector('#file-preview-controls');
        const zoomLevel = modal.querySelector('#zoom-level');

        const setZoomDisplay = (s) => { if (zoomLevel) zoomLevel.textContent = Math.round(s * 100) + '%'; };
        setZoomDisplay(modal._scale);

        const createInnerWrapper = () => {
          const inner = document.createElement('div');
          inner.id = 'file-preview-inner';
          inner.style.transition = 'transform 120ms ease';
          inner.style.willChange = 'transform';
          inner.style.cursor = 'grab';
          inner.style.display = 'flex';
          inner.style.alignItems = 'center';
          inner.style.justifyContent = 'center';
          inner.style.minWidth = '100%';
          inner.style.minHeight = '100%';
          inner.style.position = 'absolute';
          inner.style.left = '0';
          inner.style.top = '0';
          inner.style.transformOrigin = 'center center';
          return inner;
        };

        const inner = createInnerWrapper();
        body.appendChild(inner);

        let contentEl;
        if (type === 'image') {
          const img = document.createElement('img');
          img.src = url;
          img.alt = displayName;
          img.style.maxWidth = '100%';
          img.style.maxHeight = '80vh';
          img.style.userSelect = 'none';
          img.style.pointerEvents = 'none';
          contentEl = img;
          inner.appendChild(img);
        } else {
          const iframeWrap = document.createElement('div');
          iframeWrap.style.width = '100%';
          iframeWrap.style.height = '100%';
          iframeWrap.style.display = 'flex';
          iframeWrap.style.alignItems = 'center';
          iframeWrap.style.justifyContent = 'center';
          const iframe = document.createElement('iframe');
          iframe.src = url;
          iframe.style.width = '100%';
          iframe.style.height = '100%';
          iframe.style.border = 'none';
          iframe.style.pointerEvents = 'auto';
          contentEl = iframeWrap;
          iframeWrap.appendChild(iframe);
          inner.appendChild(iframeWrap);
        }

        const applyTransform = () => {
          inner.style.transform = `translate(${modal._translateX}px, ${modal._translateY}px) scale(${modal._scale})`;
          setZoomDisplay(modal._scale);
        };

        // Zoom controls
        const zoomIn = () => { modal._scale = Math.min(5, modal._scale + 0.1); applyTransform(); };
        const zoomOut = () => { modal._scale = Math.max(0.2, modal._scale - 0.1); applyTransform(); };
        const zoomReset = () => { modal._scale = 1; modal._translateX = 0; modal._translateY = 0; applyTransform(); };

        // Attach control handlers (avoid duplicate listeners)
        if (controls) {
          const inBtn = modal.querySelector('#zoom-in');
          const outBtn = modal.querySelector('#zoom-out');
          const resetBtn = modal.querySelector('#zoom-reset');
          if (inBtn && !inBtn._bound) { inBtn.addEventListener('click', zoomIn); inBtn._bound = true; }
          if (outBtn && !outBtn._bound) { outBtn.addEventListener('click', zoomOut); outBtn._bound = true; }
          if (resetBtn && !resetBtn._bound) { resetBtn.addEventListener('click', zoomReset); resetBtn._bound = true; }
        }

        // Wheel to zoom
        const wheelHandler = (ev) => {
          ev.preventDefault();
          const delta = ev.deltaY || ev.wheelDelta;
          if (delta > 0) zoomOut(); else zoomIn();
        };
        if (!modal._wheelBound) { body.addEventListener('wheel', wheelHandler, { passive: false }); modal._wheelBound = true; }

        // Drag to pan
        let dragging = false; let startX = 0; let startY = 0;
        const pointerDown = (e) => { dragging = true; inner.style.cursor = 'grabbing'; startX = e.clientX; startY = e.clientY; e.preventDefault(); };
        const pointerMove = (e) => {
          if (!dragging) return;
          const dx = e.clientX - startX; const dy = e.clientY - startY; startX = e.clientX; startY = e.clientY;
          modal._translateX += dx; modal._translateY += dy; applyTransform();
        };
        const pointerUp = () => { dragging = false; inner.style.cursor = 'grab'; };
        if (!inner._pointerBound) {
          inner.addEventListener('pointerdown', pointerDown);
          window.addEventListener('pointermove', pointerMove);
          window.addEventListener('pointerup', pointerUp);
          inner._pointerBound = true;
        }

        // Apply initial transform
        applyTransform();
      };

      return (
        <tr className="bg-[#151b28] hover:bg-[#1a202e]">
          <td className="px-6 py-4 text-gray-300 font-medium">{requirement}</td>
          <td className="px-6 py-4 text-gray-400">{modifiedDate}</td>
          <td className="px-6 py-4">
            {doc.downloadUrl ? (
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-3 text-yellow-500">
                  {getFileIcon()}
                  <div>
                    <div className="font-medium text-sm">{displayName || `${requirement}.file`}</div>
                    {fileSize !== 'Unknown' ? (
                      <div className="text-xs text-gray-400">{fileSize}</div>
                    ) : null}
                  </div>
                </div>

                <div className="flex items-center gap-2">
                  <button
                    type="button"
                    title={`Preview ${displayName}`}
                    className="p-2 rounded hover:bg-gray-800 text-gray-200"
                    onClick={(e) => { e.preventDefault(); showPreview(doc.downloadUrl, fileType); }}
                  >
                    {/* Eye icon */}
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.477 0 8.268 2.943 9.542 7-1.274 4.057-5.065 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                  </button>
                </div>
              </div>
            ) : (
              <span className="text-gray-400 text-sm">URL unavailable</span>
            )}
          </td>
        </tr>
      );
    };

    ReactDOM.createRoot(document.getElementById("root")).render(<TricycleManagement />);
  </script>
</body>
</html>